import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabaseClient'; // Adjust path as needed
import { CartItem } from '@/lib/supabaseClient'; // Import CartItem interface

interface CustomerInfo {
  name: string;
  email?: string;
  phone_number: string;
  address: string;
}

interface RequestBody {
  customerInfo: CustomerInfo;
  cartItems: CartItem[];
}

export async function POST(req: NextRequest) {
  try {
    const { customerInfo, cartItems }: RequestBody = await req.json();

    if (!customerInfo || !cartItems || cartItems.length === 0) {
      return NextResponse.json({ message: 'Missing customer information or cart items.' }, { status: 400 });
    }

    // Use a Supabase transaction or a series of calls.
    // A PL/pgSQL function in Supabase would be best for atomicity.
    // For now, we'll do it step by step. If any step fails, an error will be thrown.

    // 1. Create Customer
    const { data: customerData, error: customerError } = await supabase
      .from('customers')
      .insert({
        name: customerInfo.name,
        email: customerInfo.email || null, // Handle optional email
        phone_number: customerInfo.phone_number,
        address: customerInfo.address,
      })
      .select()
      .single();

    if (customerError || !customerData) {
      console.error('Error creating customer:', customerError);
      throw new Error('Failed to save customer details. ' + (customerError?.message || ''));
    }

    const customerId = customerData.id;

    // 2. Calculate total amount based on frontend_price from cartItems (which already has markup)
    const totalAmount = cartItems.reduce((sum, item) => sum + item.frontend_price * item.cartQuantity, 0);

    // 3. Create Order (order_number will be auto-generated by the trigger)
    const { data: orderData, error: orderError } = await supabase
      .from('orders')
      .insert({
        customer_id: customerId,
        total_amount: totalAmount,
        status: 'pending', // Default status
      })
      .select()
      .single();
    
    if (orderError || !orderData) {
      console.error('Error creating order:', orderError);
      // Potentially delete the customer if order creation fails? Or handle cleanup.
      throw new Error('Failed to create order. ' + (orderError?.message || ''));
    }
    const orderId = orderData.id;
    const orderNumber = orderData.order_number; // Get the auto-generated order number

    // 4. Create Order Items and Decrease Product Quantities
    for (const item of cartItems) {
      const { error: orderItemError } = await supabase
        .from('order_items')
        .insert({
          order_id: orderId,
          product_id: item.id,
          vendor_id: item.vendor_id, // Ensure vendor_id is part of CartItem if not already
          quantity: item.cartQuantity,
          unit_price: item.frontend_price, // This is the price customer sees (with markup)
          base_unit_price: item.base_price, // Vendor's original price
          total_price: item.frontend_price * item.cartQuantity,
        });

      if (orderItemError) {
        console.error(`Error creating order item for product ${item.id}:`, orderItemError);
        // This is where a transaction rollback would be ideal.
        // For now, we'll throw, but data might be partially inconsistent.
        throw new Error(`Failed to add item ${item.name} to order. ` + orderItemError.message);
      }

      // Decrease product quantity using the Supabase function
      const { error: decreaseQuantityError, data: updatedProduct } = await supabase.rpc(
        'decrease_product_quantity',
        {
          p_id: item.id,
          p_quantity_to_decrease: item.cartQuantity,
        }
      );

      if (decreaseQuantityError) {
        console.error(`Error decreasing quantity for product ${item.id}:`, decreaseQuantityError);
        // This is a critical error. A transaction would auto-rollback.
        // Here, the order might be created but stock not updated, or vice-versa.
        throw new Error(
          `Failed to update stock for ${item.name}. ` +
          (decreaseQuantityError.message.includes('insufficient stock')
            ? 'Insufficient stock.'
            : decreaseQuantityError.message)
        );
      }
    }

    return NextResponse.json({ message: 'Order placed successfully!', orderId, orderNumber }, { status: 201 });

  } catch (error: any) {
    console.error('API Create Order Error:', error);
    return NextResponse.json({ message: error.message || 'Internal Server Error' }, { status: 500 });
  }
}